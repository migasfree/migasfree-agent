#!/usr/bin/python3
"""
migasfree-agent - Multi-protocol TCP Tunnel Agent (SSH, VNC, RDP, etc.)

This agent establishes secure WebSocket connections to relay servers,
enabling remote access to local services through mTLS authentication.
"""

import asyncio
import json
import logging
import socket
import ssl
import sys
import time
import uuid
from contextlib import suppress

try:
    from dataclasses import dataclass, field
except ImportError:
    from dataclasses import dataclass, field  # backport: pip install dataclasses
from typing import Dict, Optional

import requests
import websockets
from migasfree_client import settings
from migasfree_client.mtls import (
    get_mtls_ca_file,
    get_mtls_cert_file,
    get_mtls_key_file,
)
from migasfree_client.utils import get_config

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
logger = logging.getLogger(__name__)

# Constants
EVENTS_JSON_FILE = settings.EVENTS_JSON_FILE
DEFAULT_SERVICES = {
    'ssh': 22,
    'vnc': 5900,
    'rdp': 3389,
    'exec': 0,
}  # exec doesn't need a port
RECONNECT_DELAY = 5
# Allowed commands for execution (whitelist for security)
ALLOWED_COMMANDS = ['migasfree']
PORT_CHECK_TIMEOUT = 0.5
BUFFER_SIZE = 8192
WEBSOCKET_CONFIG = {
    'ping_interval': 20,
    'ping_timeout': 60,
    'close_timeout': 10,
    'max_size': 10**7,
}


@dataclass
class TunnelInfo:
    """Stores information about an active tunnel."""

    reader: asyncio.StreamReader
    writer: asyncio.StreamWriter
    service: str
    port: int
    start_time: float
    client_cn: Optional[str] = None


@dataclass
class SSLConfig:
    """SSL/mTLS configuration."""

    fqdn: str
    key_file: str = field(init=False)
    cert_file: str = field(init=False)
    ca_file: str = field(init=False)
    context: ssl.SSLContext = field(init=False)

    def __post_init__(self):
        self.key_file = get_mtls_key_file(self.fqdn)
        self.cert_file = get_mtls_cert_file(self.fqdn)
        self.ca_file = get_mtls_ca_file(self.fqdn)
        self.context = self._create_context()

    def _create_context(self) -> ssl.SSLContext:
        """Creates and configures SSL context."""
        ctx = ssl.create_default_context()
        try:
            ctx.load_verify_locations(cafile=self.ca_file)
        except Exception as e:
            logger.error(f'Failed to load CA certificate: {e}')

        try:
            ctx.load_cert_chain(certfile=self.cert_file, keyfile=self.key_file)
        except Exception as e:
            logger.warning(f'Failed to load mTLS certificate: {e}')

        return ctx


class MultiProtocolAgent:
    """
    Agent that creates TCP tunnels through WebSocket connections.

    Supports multiple protocols (SSH, VNC, RDP, etc.) by forwarding
    local ports through a secure relay server.
    """

    def __init__(
        self,
        manager_url: str,
        ssl_config: SSLConfig,
        agent_id: Optional[int] = None,
        project: Optional[str] = None,
        services: Optional[Dict[str, int]] = None,
    ):
        self.manager_url = manager_url.rstrip('/')
        self.ssl_config = ssl_config
        self.server_url: Optional[str] = None
        self.agent_id = agent_id or str(uuid.uuid4())
        self.project = project or 'Unknown'
        self.hostname = socket.gethostname()
        self.services = services or DEFAULT_SERVICES.copy()
        self.tcp_tunnels: Dict[str, TunnelInfo] = {}
        self.websocket: Optional[websockets.WebSocketClientProtocol] = None

    def _is_port_open(self, port: int) -> bool:
        """Checks if a port is open on localhost."""
        with suppress(OSError), socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(PORT_CHECK_TIMEOUT)
            return sock.connect_ex(('127.0.0.1', port)) == 0
        return False

    def _get_system_info(self) -> dict:
        """Gets system information and active services."""
        active_services = []

        for name, port in self.services.items():
            if self._is_port_open(port):
                active_services.append(name)

        return {
            'services': active_services,
        }

    def _format_duration(self, seconds: float) -> str:
        """Formats duration in HH:MM:SS format."""
        hours, remainder = divmod(seconds, 3600)
        minutes, secs = divmod(remainder, 60)
        return f'{int(hours):02}:{int(minutes):02}:{int(secs):02}'

    async def _register(self) -> None:
        """Registers the agent with the server via WebSocket."""
        message = {
            'type': 'register_agent',
            'id': self.agent_id,
            'name': f'{self.hostname} [CID-{self.agent_id}]',
            'services': self._get_system_info()['services'],
            'mode': 'tcp_tunnel',
        }
        await self.websocket.send(json.dumps(message))
        logger.info(f'Agent registered: {self.agent_id}')

    async def _handle_tcp_tunnel(
        self,
        tunnel_id: str,
        service: str = 'ssh',
        client_cn: Optional[str] = None,
    ) -> None:
        """Handles a TCP tunnel to any local service."""
        if service not in self.services:
            logger.error(f"Service '{service}' not available.")
            return

        port = self.services[service]
        logger.info(f'Starting tunnel {service.upper()}: {tunnel_id} -> port {port} (Client: {client_cn})')

        try:
            reader, writer = await asyncio.open_connection('127.0.0.1', port)
            self.tcp_tunnels[tunnel_id] = TunnelInfo(
                reader=reader,
                writer=writer,
                service=service,
                port=port,
                start_time=time.time(),
                client_cn=client_cn,
            )
            asyncio.create_task(self._forward_service_to_ws(tunnel_id, reader, service))  # noqa: RUF006
        except OSError as e:
            logger.error(f'Error connecting to local service {service}: {e}')
            await self._close_tcp_tunnel(tunnel_id)

    async def _forward_service_to_ws(
        self,
        tunnel_id: str,
        reader: asyncio.StreamReader,
        service: str,
    ) -> None:
        """Forwards data from local service to WebSocket."""
        try:
            while tunnel_id in self.tcp_tunnels:
                data = await reader.read(BUFFER_SIZE)
                if not data:
                    break
                message = {
                    'type': 'tunnel_data',
                    'tunnel_id': tunnel_id,
                    'origin': 'agent',
                    'data': data.hex(),
                }
                await self.websocket.send(json.dumps(message))
        except Exception as e:
            logger.error(f'Error reading service {service}: {e}')
        finally:
            await self._close_tcp_tunnel(tunnel_id)

    async def _write_tcp_tunnel(self, tunnel_id: str, data_hex: str) -> None:
        """Writes data to an existing tunnel."""
        if tunnel_id not in self.tcp_tunnels:
            return

        try:
            data = bytes.fromhex(data_hex)
            writer = self.tcp_tunnels[tunnel_id].writer
            writer.write(data)
            await writer.drain()
        except Exception as e:
            logger.error(f'Error writing to tunnel: {e}')
            await self._close_tcp_tunnel(tunnel_id)

    async def _close_tcp_tunnel(self, tunnel_id: str) -> None:
        """Closes a tunnel and cleans up resources."""
        if tunnel_id not in self.tcp_tunnels:
            return

        tunnel = self.tcp_tunnels.pop(tunnel_id)

        with suppress(Exception):
            tunnel.writer.close()
            await tunnel.writer.wait_closed()

        duration_str = self._format_duration(time.time() - tunnel.start_time)
        client_str = f' (Client: {tunnel.client_cn})' if tunnel.client_cn else ''
        logger.info(f'Tunnel closed {tunnel.service.upper()}: {tunnel_id} (Duration: {duration_str}){client_str}')

        if self.websocket:
            with suppress(Exception):
                await self.websocket.send(json.dumps({'type': 'tunnel_closed', 'tunnel_id': tunnel_id}))

    async def _handle_messages(self) -> None:
        """Processes incoming WebSocket messages."""
        handlers = {
            'start_tcp_tunnel': self._handle_start_tunnel,
            'tunnel_data': self._handle_tunnel_data,
            'close_tcp_tunnel': self._handle_close_tunnel,
            'execute_command': self._handle_execute_command,
        }
        # Handlers that should run in background (non-blocking)
        background_handlers = {'execute_command'}

        try:
            async for message_raw in self.websocket:
                message = json.loads(message_raw)
                msg_type = message.get('type')
                handler = handlers.get(msg_type)
                if handler:
                    # Execute long-running commands in background to not block other messages
                    if msg_type in background_handlers:
                        asyncio.create_task(handler(message))  # noqa: RUF006
                    else:
                        await handler(message)
        except websockets.ConnectionClosed:
            logger.warning('WebSocket connection closed')
        except Exception as e:
            logger.error(f'WebSocket error: {e}')

    async def _handle_start_tunnel(self, message: dict) -> None:
        """Handles start_tcp_tunnel message."""
        await self._handle_tcp_tunnel(
            message.get('tunnel_id'),
            message.get('service', 'ssh'),
            message.get('client_cn'),
        )

    async def _handle_tunnel_data(self, message: dict) -> None:
        """Handles tunnel_data message."""
        await self._write_tcp_tunnel(
            message.get('tunnel_id'),
            message.get('data'),
        )

    async def _handle_close_tunnel(self, message: dict) -> None:
        """Handles close_tcp_tunnel message."""
        await self._close_tcp_tunnel(message.get('tunnel_id'))

    async def _handle_execute_command(self, message: dict) -> None:
        """Handles remote command execution."""
        command = message.get('command', '')
        exec_id = message.get('exec_id')
        client_cn = message.get('client_cn', 'unknown')

        if not command or not exec_id:
            logger.error('Invalid execute_command message: missing command or exec_id')
            return

        # Validate command is in whitelist
        command_parts = command.split()
        if not command_parts:
            await self._send_exec_error(exec_id, 'Empty command')
            return

        base_command = command_parts[0]
        if base_command not in ALLOWED_COMMANDS:
            error_msg = f'Command "{base_command}" not allowed. Allowed: {", ".join(ALLOWED_COMMANDS)}'
            logger.warning(f'Rejected command from {client_cn}: {command}')
            await self._send_exec_error(exec_id, error_msg)
            return

        logger.info(f'Executing command from {client_cn}: {command}')

        try:
            # Execute command with streaming output (non-interactive)
            process = await asyncio.create_subprocess_shell(
                command,
                stdin=asyncio.subprocess.DEVNULL,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            # Stream stdout and stderr concurrently
            async def stream_output(stream, stream_type):
                try:
                    while True:
                        line = await stream.readline()
                        if not line:
                            break
                        await self.websocket.send(
                            json.dumps(
                                {
                                    'type': 'exec_output',
                                    'exec_id': exec_id,
                                    'stream': stream_type,
                                    'data': line.decode('utf-8', errors='replace'),
                                }
                            )
                        )
                except Exception as e:
                    logger.error(f'Error streaming {stream_type}: {e}')

            # Wait for both streams and process completion
            await asyncio.gather(
                stream_output(process.stdout, 'stdout'),
                stream_output(process.stderr, 'stderr'),
            )

            exit_code = await process.wait()

            # Send completion message
            await self.websocket.send(
                json.dumps(
                    {
                        'type': 'exec_complete',
                        'exec_id': exec_id,
                        'exit_code': exit_code,
                    }
                )
            )

            logger.info(f'Command completed with exit code {exit_code}: {command}')

        except Exception as e:
            logger.error(f'Error executing command: {e}')
            await self._send_exec_error(exec_id, str(e))

    async def _send_exec_error(self, exec_id: str, error_msg: str) -> None:
        """Sends an execution error message."""
        try:
            await self.websocket.send(
                json.dumps(
                    {
                        'type': 'exec_error',
                        'exec_id': exec_id,
                        'error': error_msg,
                    }
                )
            )
        except Exception as e:
            logger.error(f'Failed to send exec error: {e}')

    async def _fetch_relay_assignment(self) -> Optional[str]:
        """Fetches relay server assignment from manager."""
        logger.info(f'Contacting Manager at {self.manager_url}')

        def do_request():
            return requests.post(
                f'{self.manager_url}/register',
                json={
                    'id': self.agent_id,
                    'name': self.hostname,
                    'services': self._get_system_info()['services'],
                },
                timeout=5,
                cert=(self.ssl_config.cert_file, self.ssl_config.key_file),
                verify=self.ssl_config.ca_file,
            )

        try:
            loop = asyncio.get_event_loop()
            resp = await loop.run_in_executor(None, do_request)
            resp.raise_for_status()
            return resp.json()['relay']
        except requests.RequestException as e:
            logger.error(f'Manager error: {e}')
            return None

    def _build_connect_kwargs(self, headers: dict) -> dict:
        """Builds WebSocket connection kwargs."""
        kwargs = WEBSOCKET_CONFIG.copy()

        if self.server_url.startswith('wss://'):
            kwargs['ssl'] = self.ssl_config.context

        # Try extra_headers first (older websockets versions)
        kwargs['extra_headers'] = headers
        return kwargs

    async def _connect_websocket(self, connect_kwargs: dict, headers: dict):
        """Connects to WebSocket with version compatibility handling."""
        try:
            return await websockets.connect(self.server_url, **connect_kwargs)
        except TypeError as e:
            if 'extra_headers' not in str(e):
                raise
            # Fallback to additional_headers (newer versions)
            del connect_kwargs['extra_headers']
            connect_kwargs['additional_headers'] = headers
            return await websockets.connect(self.server_url, **connect_kwargs)

    async def connect(self) -> None:
        """Main connection loop with automatic reconnection."""
        while True:
            try:
                if not self.server_url:
                    self.server_url = await self._fetch_relay_assignment()
                    if not self.server_url:
                        await asyncio.sleep(RECONNECT_DELAY)
                        continue

                logger.info(f'Connecting to {self.server_url}')
                headers = {'X-Agent-ID': self.agent_id}
                connect_kwargs = self._build_connect_kwargs(headers)

                async with await self._connect_websocket(connect_kwargs, headers) as ws:
                    self.websocket = ws
                    logger.info('Connection established')
                    await self._register()
                    await self._handle_messages()

                logger.warning('Disconnected from Relay')
                self.server_url = None

            except Exception as e:
                logger.error(f'Connection error: {e}')
                self.server_url = None
                await asyncio.sleep(RECONNECT_DELAY)


def load_agent_config() -> tuple[str, str]:
    """Loads agent configuration from traits file."""
    with open(EVENTS_JSON_FILE) as f:
        traits = json.load(f)
    agent_id = int(traits['after']['CID'][0])
    project = traits['after']['PRJ'][0]
    return agent_id, project


async def main():
    """Main entry point."""
    fqdn = get_config(settings.CONF_FILE, 'client').get('server', 'localhost')
    ssl_config = SSLConfig(fqdn)
    manager_url = f'https://{fqdn}/manager/v1/private/tunnel'

    agent_id, project = load_agent_config()

    agent = MultiProtocolAgent(
        manager_url=manager_url,
        ssl_config=ssl_config,
        services=DEFAULT_SERVICES,
        agent_id=agent_id,
        project=project,
    )
    await agent.connect()


if __name__ == '__main__':
    try:
        if sys.version_info >= (3, 7):  # noqa: UP036
            asyncio.run(main())
        else:
            loop = asyncio.get_event_loop()
            loop.run_until_complete(main())
    except KeyboardInterrupt:
        logger.info('Agent stopped')
